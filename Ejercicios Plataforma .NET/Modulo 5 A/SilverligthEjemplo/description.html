<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
    <head>



        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>Lissajous Animations in Silverlight - Charles Petzold</title>
        <link href="description/Galleries.css" type="text/css" rel="Stylesheet" /><link href="description/Layout.css" type="text/css" rel="Stylesheet" /><link href="description/Brand.css" type="text/css" rel="Stylesheet" />
        <link href="description/iframedescription.css" rel="Stylesheet" type="text/css" />
        <script src="description/offline.js" type="text/javascript"></script>
        <style type="text/css">
            #projectInfo {
                overflow: auto;
            }
            #longDesc {
                clear:both;
                margin: 25px 0 10px 0;
            }

            #SampleIndexList{
                margin-left: 15px;
            }
        </style>
    </head>
<body>
    <div id="offlineDescription">
        <div id="projectInfo">
            <div class="section">
                    <div class="itemBarLong tagsContainer">
                        <label for="Technologies">Technologies</label>
                        <div id="Technologies">
                            Silverlight, Windows Phone 7
                        </div>
                    </div>
                    <div class="itemBarLong tagsContainer">
                        <label for="Topics">Topics</label>
                        <div id="Topics">
                            Controls, Lissajous Curve
                        </div>
                    </div>
                <div class="itemBar">
                    <label for="LastUpdated">Last Updated</label>
                    <div id="LastUpdated">5/2/2011</div>
                </div>
                <div class="itemBarLong">
                    <label for="License">License</label>
                    <div id="License">
                        <a href="license.rtf">Apache License, Version 2.0</a></div>
                </div>
                <div class="itemBar">
                    <div class="viewonlinecont">
                        <a data-link="online" href="http://code.msdn.microsoft.com/Lissajous-Animations-in-1b3ffd59">View this sample online</a>
                    </div>
                </div>
            </div>
        </div>
        
                   
<script type="text/javascript">
    function initializePage() {
        var otherTabClass = 'otherTab';
        var hiddenPreClass = 'hidden';

        var htmlDecode = function(encodedData) {
            var decodedData = "";
            if (encodedData) {
                var div = document.createElement('div');
                div.innerHTML = encodedData;
                decodedData = div.firstChild.nodeValue.replace( /\\r\\n/ig , '\r\n');
            }
            return decodedData;
        };
                
        Galleries.iterateElem(Galleries.findElem(null, 'div', 'scriptcode'), function (index, scriptBlock) {
            var titleElem = Galleries.findElem(scriptBlock, 'div', 'title')[0];
            var labelElems = Galleries.findElem(titleElem, 'span');
            if (labelElems.length == 0) {
                labelElems = titleElem;
            }
            var languageSpans = Galleries.findElem(scriptBlock, 'span', 'hidden');
            var pres = Galleries.findElem(scriptBlock, 'pre');
            if (languageSpans.length > 0 && pres.length > 1) {
                Galleries.iterateElem(labelElems, function(index, elem) {
                    var codePre = pres[index];
                    var labelSpan = elem;
                    var languageSpan = languageSpans[index];
                            
                    elem.code = codePre.innerHTML.replace( /(\r(\n)?)|((\r)?\n)/ig , '\\r\\n');
                            
                    codePre.className = codePre.className.replace(hiddenPreClass, '');
                            
                    languageSpan.parentNode.removeChild(languageSpan);
                });

                pres = Galleries.findElem(scriptBlock, 'pre');
                Galleries.iterateElem(labelElems, function(index, elem) {
                    var codePre = pres[index];
                    var labelSpan = elem;
                    if (index == 0) {
                        scriptBlock.activeTab = 0;
                    }
                    else {
                        labelSpan.className += otherTabClass;
                        codePre.className += hiddenPreClass;
                    }
                    Galleries.attachEventHandler(labelSpan, 'click', function(e) {
                        var activeTab = scriptBlock.activeTab;
                        labelElems[activeTab].className += otherTabClass;
                        pres[activeTab].className += hiddenPreClass;

                        codePre.className = codePre.className.replace(hiddenPreClass, '');
                        labelSpan.className = labelSpan.className.replace(otherTabClass, '');
                        scriptBlock.activeTab = index;
                    });
                });

                var preview = Galleries.findElem(scriptBlock, 'div', 'preview');
                if (preview.length == 0) {
                    preview.push(pres[pres.length - 1]);
                }
                Galleries.iterateElem(preview, function(index, elem) {
                    elem.parentNode.removeChild(elem);
                });

                if (window.clipboardData && clipboardData.setData) {
                    var copyLink = document.createElement('a');
                    copyLink.href = 'javascript:void(0);';
                    copyLink.className = 'copyCode';
                    copyLink.innerHTML = 'Copy Code';
                    Galleries.attachEventHandler(copyLink, 'click', function (e) {
                        clipboardData.setData("Text", htmlDecode(labelElems[scriptBlock.activeTab].code));
                        return false;
                    });
                    scriptBlock.insertBefore(copyLink, scriptBlock.childNodes[0]);
                }
            }
        });
    }

    Galleries.onWindowLoad(function(){
        initializePage();
    });

</script>
<div id="longDesc">
    
<p><img src="description/gg983480.charles_petzold_headshot(en-us%2cmsdn.10).jpg" alt="" width="100" height="150" style="float:left; padding-right:5px">We commonly think of software as
 more flexible and versatile than hardware. It&rsquo;s certainly true in many cases, because hardware is often stuck in one configuration while software can be reprogrammed to perform completely different tasks.</p>
<p>Yet some rather prosaic pieces of hardware are actually quite versatile. Consider the common&mdash;or these days, not so common&mdash;cathode ray tube (CRT). This is a device that shoots a stream of electrons on the inside of a glass screen. The screen is
 coated with a fluorescent material that reacts to these electrons by briefly glowing.</p>
<p>In old-time TV sets and computer monitors, the electron gun moves in a steady pattern, repetitively sweeping horizontally across the screen while traveling more slowly from top to bottom. The intensity of electrons at any time determines the brightness of
 a dot at that point. For color displays, separate electron guns are used to create the primary red, green and blue colors.</p>
<p>The direction of the electron gun is controlled by electromagnets, and it can actually be aimed at any arbitrary location on the two-dimensional surface of the glass. This is how the CRT is used in an oscilloscope. Most commonly, the beam sweeps horizontally
 across the screen at a constant rate, usually in synchronization with a particular input waveform. The vertical deflection shows the amplitude of that waveform at that point. The fairly long persistence of the fluorescent material used in oscilloscopes allows
 the entire waveform to be displayed&mdash;in effect &ldquo;freezing&rdquo; the waveform to be visually examined.</p>
<p>Oscilloscopes also have an X-Y mode that allows the horizontal and vertical deflection of the electron gun to be controlled by two independent inputs, usually waveforms such as sine curves. With two sine curves as input, at any point in time the point (x,
 y) is illuminated, where x and y are given by the parametric equations:</p>
<p><img title="parametric equations" src="http://i.msdn.microsoft.com/gg983480.Petzold_sub(en-us,MSDN.10).png" alt="parametric equations" align="Middle"></p>
<p>The A values are amplitudes, the &omega; values are frequencies and the k values are phase offsets.</p>
<p>The pattern resulting from the interaction of these two sine waves is a Lissajous curve, named after French mathematician Jules Antoine Lissajous (1822 - 1880) who first visually created these curves by bouncing light between a pair of mirrors attached to
 vibrating tuning forks.</p>
<p>You can experiment with a Silverlight program that generates Lissajous curves on my Web site (<a id="ctl00_MTContentSelector1_mainContentContainer_ctl03" href="http://charlespetzold.com/silverlight/LissajousCurves/LissajousCurves.html">charlespetzold.com/silverlight/LissajousCurves/LissajousCurves.html</a>).&nbsp;<strong>Figure
 1</strong>&nbsp;shows a typical display.</p>
<p><img title="The Web Version of the LissajousCurves Program" src="http://i.msdn.microsoft.com/gg983480.Petzold_Figure1_hires(en-us,MSDN.10).jpg" alt="image: The Web Version of the LissajousCurves Program"></p>
<p>Figure 1&nbsp;<strong>The Web Version of the LissajousCurves Program</strong></p>
<p>Although it&rsquo;s not quite obvious in a static screenshot, a green point is moving around the dark gray screen and leaving behind a trail that fades out over four seconds. The horizontal position of this point is governed by one sine curve, and the vertical
 position by another. Repetitive patterns result when the two frequencies are simple integral ratios.</p>
<p>It&rsquo;s now a truth universally acknowledged that a Silverlight program of any good fortune must be ported to Windows Phone 7, and subsequently reveal any performance problems previously masked by high-powered desktop computers. That was certainly the
 case with this program, and I&rsquo;ll be discussing these performance issues later in this article.&nbsp;<strong>Figure 2</strong>&nbsp;shows the program running on the Windows Phone 7 emulator.</p>
<p><img title="The LissajousCurves Program for Windows Phone 7" src="http://i.msdn.microsoft.com/gg983480.Petzold_Figure2_hires(en-us,MSDN.10).jpg" alt="image: The LissajousCurves Program for Windows Phone 7"></p>
<p>Figure 2&nbsp;<strong>The LissajousCurves Program for Windows Phone 7</strong></p>
<p>The downloadable code consists of a single Visual Studio solution named LissajousCurves. The Web application consists of the projects LissajousCurves and LissajousCurves.Web. The Windows Phone 7 application has the project name LissajousCurves.Phone. The
 solution also contains two library projects: Petzold.Oscilloscope.Silverlight and Petzold.Oscilloscope.Phone, but these two projects share all the same code files.</p>
<h2>Push or Pull?</h2>
<p>Aside from the TextBlock and Slider controls, the only other visual element in this program is a class named Oscilloscope that derives from UserControl. Providing the data for Oscilloscope are two instances of a class named SineCurve.</p>
<p>SineCurve has no visuals itself, but I derived the class from FrameworkElement so I could put the two instances in the visual tree and define bindings on them. In fact, everything in the program is connected with bindings&mdash;from the Slider controls to
 the SineCurve elements and from SineCurve to Oscilloscope. The MainPage.xaml.cs file for the Web version of the program has no code beyond what&rsquo;s provided by default, and the equivalent file in the phone application only implements Tombstoning logic.</p>
<p>SineCurve defines two properties (backed by dependency properties) named Frequency and Amplitude. One SineCurve instance provides the horizontal values for Oscilloscope, and the other the vertical values.</p>
<p>The SineCurve class also implements an interface I called IProvideAxisValue:</p>
<div class="scriptcode">
<div class="pluginEditHolder" pluginCommand="mceScriptCode">
<div class="title"><span>C#</span></div>
<div class="pluginLinkHolder"><span class="pluginEditHolderLink">Edit</span>|<span class="pluginRemoveHolderLink">Remove</span></div>
<span class="hidden">csharp</span>
<pre class="hidden">public interface IProvideAxisValue {
  double GetAxisValue(DateTime dateTime);
}</pre>
<div class="preview">
<pre class="js">public&nbsp;interface&nbsp;IProvideAxisValue&nbsp;<span class="js__brace">{</span>&nbsp;
&nbsp;&nbsp;double&nbsp;GetAxisValue(DateTime&nbsp;dateTime);&nbsp;
<span class="js__brace">}</span>&nbsp;
&nbsp;
</pre>
</div>
</div>
</div>
<div class="endscriptcode">&nbsp;SineCurve implements this interface with a rather simple method that references two fields as well as the two properties:</div>
<div class="scriptcode">
<div class="pluginEditHolder" pluginCommand="mceScriptCode">
<div class="title"><span>C#</span></div>
<div class="pluginLinkHolder"><span class="pluginEditHolderLink">Edit</span>|<span class="pluginRemoveHolderLink">Remove</span></div>
<span class="hidden">csharp</span>
<pre class="hidden">public double GetAxisValue(DateTime dateTime) {
  phaseAngle &#43;= 2 * Math.PI * this.Frequency * 
    (dateTime - lastDateTime).TotalSeconds;
  phaseAngle %= 2 * Math.PI;
  lastDateTime = dateTime;
 
  return this.Amplitude * Math.Sin(phaseAngle);
}</pre>
<div class="preview">
<pre class="csharp"><span class="cs__keyword">public</span>&nbsp;<span class="cs__keyword">double</span>&nbsp;GetAxisValue(DateTime&nbsp;dateTime)&nbsp;{&nbsp;
&nbsp;&nbsp;phaseAngle&nbsp;&#43;=&nbsp;<span class="cs__number">2</span>&nbsp;*&nbsp;Math.PI&nbsp;*&nbsp;<span class="cs__keyword">this</span>.Frequency&nbsp;*&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;(dateTime&nbsp;-&nbsp;lastDateTime).TotalSeconds;&nbsp;
&nbsp;&nbsp;phaseAngle&nbsp;%=&nbsp;<span class="cs__number">2</span>&nbsp;*&nbsp;Math.PI;&nbsp;
&nbsp;&nbsp;lastDateTime&nbsp;=&nbsp;dateTime;&nbsp;
&nbsp;&nbsp;
&nbsp;&nbsp;<span class="cs__keyword">return</span>&nbsp;<span class="cs__keyword">this</span>.Amplitude&nbsp;*&nbsp;Math.Sin(phaseAngle);&nbsp;
}&nbsp;
&nbsp;
</pre>
</div>
</div>
</div>
<div class="endscriptcode">The Oscilloscope class defines two properties (also backed by dependency properties) named XProvider and YProvider of type IProvideAxisValue. To get everything moving, Oscilloscope installs a handler for the CompositionTarget.Rendering
 event. This event is fired in synchronization with the refresh rate of the video display and thus serves as a convenient tool for performing animations. On each call to the CompositionTarget.Rendering handler, Oscilloscope calls GetAxisValue on the two SineCurve
 objects set to its XProvider and YProvider properties.</div>
<p>&nbsp;</p>
<p>In other words, the program implements a pull model. The Oscilloscope object determines when it needs data and then pulls the data from the two data providers. (How it displays that data is something I&rsquo;ll discuss soon.)</p>
<p>As I began to add more features to the program&mdash;in particular, two instances of an additional control that displayed the sine curves, but that I eventually removed as an unenlightening distraction&mdash;I began to doubt the wisdom of this model. I had
 three objects pulling the same data from two providers, and I thought maybe a push model would be better.</p>
<p>I restructured the program so that the SineCurve class installed a handler for CompositionTarget.Rendering and pushed data to the Oscilloscope control through properties now named simply X and Y of type double.</p>
<p>I probably should&rsquo;ve anticipated the fundamental flaw in this particular push model: The Oscilloscope was now receiving two separate changes in X and Y and constructing not a smooth curve but a series of stair steps, as shown in&nbsp;<strong>Figure
 3</strong>.</p>
<p><img title="The Disastrous Result of a Push-Model Experiment" src="http://i.msdn.microsoft.com/gg983480.Petzold_Figure3_hires(en-us,MSDN.10).jpg" alt="image: The Disastrous Result of a Push-Model Experiment"></p>
<p>Figure 3&nbsp;<strong>The Disastrous Result of a Push-Model Experiment</strong></p>
<p>Making the decision to go back to the pull model was easy!</p>
<h2>Rendering with WriteableBitmap</h2>
<p>From the moment I conceived this program, there was absolutely no question in my mind that using WriteableBitmap was the best solution to implement the actual Oscilloscope screen.</p>
<p>WriteableBitmap is a Silverlight bitmap that supports pixel addressing. All the pixels of the bitmap are exposed as an array of 32-bit integers. Programs can obtain and set these pixels in an arbitrary manner. WriteableBitmap also has a Render method that
 allows rendering the visuals of any object of type FrameworkElement onto the bitmap.</p>
<p>If Oscilloscope just needed to display a simple static curve, I&rsquo;d use Polyline or Path and wouldn&rsquo;t even consider WriteableBitmap. Even if that curve needed to change shape, Polyline or Path would still be preferable. But the curve displayed
 by Oscilloscope needs to grow in size, and it needs to be colored oddly. The line needs to fade out progressively: Recently displayed parts of the line are brighter than older parts of the line. If I used a single curve, it would need various colors along
 its length. This is not a concept â€¨supported under Silverlight!</p>
<p>Without WriteableBitmap, the program would need to create several hundred different Polyline elements, all colored differently and juggled around, and triggering layout passes after each CompositionTarget.Rendering event. Everything I knew about Silverlight
 programming indicated that WriteableBitmap would definitely offer much better performance.</p>
<p>An early version of the Oscilloscope class processed the CompositionTarget.Rendering event by obtaining new values from the two SineCurve providers, scaling those to the size of the WriteableBitmap, and then constructing a Line object from the previous point
 to the current point. That was simply passed to the Render method of WriteableBitmap:</p>
<div class="scriptcode">
<div class="pluginEditHolder" pluginCommand="mceScriptCode">
<div class="title"><span>C#</span></div>
<div class="pluginLinkHolder"><span class="pluginEditHolderLink">Edit</span>|<span class="pluginRemoveHolderLink">Remove</span></div>
<span class="hidden">csharp</span>
<pre class="hidden">writeableBitmap.Render(line, null);</pre>
<div class="preview">
<pre class="js">writeableBitmap.Render(line,&nbsp;null);&nbsp;
&nbsp;</pre>
</div>
</div>
</div>
<div class="CodeHighlighter"></div>
<p>The Oscilloscope class defines a Persistence property that indicates the number of seconds for any color or alpha component of a pixel to decrease from 255 to 0. Making those pixels fade out involved direct pixel addressing. The code is shown in&nbsp;<strong>Figure
 4</strong>.</p>
<p>Figure 4&nbsp;<strong>Code to Fade out Pixel Values</strong></p>
<div class="scriptcode">
<div class="pluginEditHolder" pluginCommand="mceScriptCode">
<div class="title"><span>C#</span></div>
<div class="pluginLinkHolder"><span class="pluginEditHolderLink">Edit</span>|<span class="pluginRemoveHolderLink">Remove</span></div>
<span class="hidden">csharp</span>
<pre class="hidden">accumulatedDecrease &#43;= 256 *  
  (dateTime - lastDateTime).TotalSeconds / Persistence; 
int decrease = (int)accumulatedDecrease; 
  
// If integral decrease, sweep through the pixels 
if (decrease &gt; 0) { 
  accumulatedDecrease -= decrease; 
  
  for (int index = 0; index &lt;  
    writeableBitmap.Pixels.Length; index&#43;&#43;) { 
  
    int pixel = writeableBitmap.Pixels[index]; 
  
    if (pixel != 0) { 
      int a = pixel &gt;&gt; 24 &amp; 0xFF; 
      int r = pixel &gt;&gt; 16 &amp; 0xFF; 
      int g = pixel &gt;&gt; 8 &amp; 0xFF; 
      int b = pixel &amp; 0xFF; 
  
      a = Math.Max(0, a - decrease); 
      r = Math.Max(0, r - decrease); 
      g = Math.Max(0, g - decrease); 
      b = Math.Max(0, b - decrease); 
  
      writeableBitmap.Pixels[index] = a &lt;&lt; 24 | r &lt;&lt; 16 | g &lt;&lt; 8 | b; 
    } 
  } 
}</pre>
<div class="preview">
<pre class="js">accumulatedDecrease&nbsp;&#43;=&nbsp;<span class="js__num">256</span>&nbsp;*&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;(dateTime&nbsp;-&nbsp;lastDateTime).TotalSeconds&nbsp;/&nbsp;Persistence;&nbsp;&nbsp;
int&nbsp;decrease&nbsp;=&nbsp;(int)accumulatedDecrease;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
<span class="js__sl_comment">//&nbsp;If&nbsp;integral&nbsp;decrease,&nbsp;sweep&nbsp;through&nbsp;the&nbsp;pixels&nbsp;</span>&nbsp;
<span class="js__statement">if</span>&nbsp;(decrease&nbsp;&gt;&nbsp;<span class="js__num">0</span>)&nbsp;<span class="js__brace">{</span>&nbsp;&nbsp;
&nbsp;&nbsp;accumulatedDecrease&nbsp;-=&nbsp;decrease;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;<span class="js__statement">for</span>&nbsp;(int&nbsp;index&nbsp;=&nbsp;<span class="js__num">0</span>;&nbsp;index&nbsp;&lt;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;writeableBitmap.Pixels.Length;&nbsp;index&#43;&#43;)&nbsp;<span class="js__brace">{</span>&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;pixel&nbsp;=&nbsp;writeableBitmap.Pixels[index];&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="js__statement">if</span>&nbsp;(pixel&nbsp;!=&nbsp;<span class="js__num">0</span>)&nbsp;<span class="js__brace">{</span>&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;a&nbsp;=&nbsp;pixel&nbsp;&gt;&gt;&nbsp;<span class="js__num">24</span>&nbsp;&amp;&nbsp;0xFF;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;pixel&nbsp;&gt;&gt;&nbsp;<span class="js__num">16</span>&nbsp;&amp;&nbsp;0xFF;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;g&nbsp;=&nbsp;pixel&nbsp;&gt;&gt;&nbsp;<span class="js__num">8</span>&nbsp;&amp;&nbsp;0xFF;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;b&nbsp;=&nbsp;pixel&nbsp;&amp;&nbsp;0xFF;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;<span class="js__object">Math</span>.Max(<span class="js__num">0</span>,&nbsp;a&nbsp;-&nbsp;decrease);&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;<span class="js__object">Math</span>.Max(<span class="js__num">0</span>,&nbsp;r&nbsp;-&nbsp;decrease);&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g&nbsp;=&nbsp;<span class="js__object">Math</span>.Max(<span class="js__num">0</span>,&nbsp;g&nbsp;-&nbsp;decrease);&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;<span class="js__object">Math</span>.Max(<span class="js__num">0</span>,&nbsp;b&nbsp;-&nbsp;decrease);&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeableBitmap.Pixels[index]&nbsp;=&nbsp;a&nbsp;&lt;&lt;&nbsp;<span class="js__num">24</span>&nbsp;|&nbsp;r&nbsp;&lt;&lt;&nbsp;<span class="js__num">16</span>&nbsp;|&nbsp;g&nbsp;&lt;&lt;&nbsp;<span class="js__num">8</span>&nbsp;|&nbsp;b;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="js__brace">}</span>&nbsp;&nbsp;
&nbsp;&nbsp;<span class="js__brace">}</span>&nbsp;&nbsp;
<span class="js__brace">}</span>&nbsp;
&nbsp;</pre>
</div>
</div>
</div>
<p>At this point in the development of the program, I took the steps necessary to also get it running on the phone. On both the Web and the phone, the program seemed to run well, but I knew it was not quite finished. I wasn&rsquo;t seeing curves on the Oscilloscope
 screen: I was seeing a bunch of connected straight lines. And nothing destroys the illusion of digitally simulated analog faster than a bunch of extremely straight lines!</p>
<p>&nbsp;</p>
<h2>Interpolation</h2>
<p>The CompositionTarget.Rendering handler is called in synchronization with the video display refresh. For most video displays&mdash;including the display on Windows Phone 7&mdash;this is usually in the region of 60 frames per second. In other words, the CompositionTarget.Rendering
 event handler is called approximately every 16 or 17 ms. (Actually, as you&rsquo;ll see, that&rsquo;s only the optimum situation.) Even if the sine waves are a leisurely one cycle per second, for a 480-pixel-wide oscilloscope, two adjacent samples might have
 pixel coordinates some 35 pixels apart.</p>
<p>The Oscilloscope needed to interpolate between consecutive samples with a curve. But what kind of curve?</p>
<p>My first choice was a canonical spline (also known as a cardinal spline). For a sequence of control points p1, p2, p3 and p4, the canonical spline provides a cubic interpolation between p2 and p3 with a degree of curviness based on a &ldquo;tension&rdquo;
 factor. It&rsquo;s a general-purpose solution.</p>
<p>The canonical spline was supported in Windows Forms, but never made it into Windows Presentation Foundation (WPF) or Silverlight. Fortunately, I had some WPF and Silverlight code for the canonical spline that I developed for a 2009 blog entry called, appropriately
 enough, &ldquo;Canonical Splines in WPF and Silverlight&rdquo; (<a id="ctl00_MTContentSelector1_mainContentContainer_ctl08" href="http://bit.ly/bDaWgt">bit.ly/bDaWgt</a>).</p>
<p>After generating a Polyline with interpolation, the CompositionTarget.Rendering processing now concluded with a call like this:</p>
<div class="scriptcode">
<div class="pluginEditHolder" pluginCommand="mceScriptCode">
<div class="title"><span>C#</span></div>
<div class="pluginLinkHolder"><span class="pluginEditHolderLink">Edit</span>|<span class="pluginRemoveHolderLink">Remove</span></div>
<span class="hidden">csharp</span>
<pre class="hidden">writeableBitmap.Render(polyline, null);</pre>
<div class="preview">
<pre class="js">writeableBitmap.Render(polyline,&nbsp;null);&nbsp;
&nbsp;</pre>
</div>
</div>
</div>
<div class="CodeHighlighter"></div>
<p>The canonical spline worked, but it was not quite right. When the frequencies of the two sine curves are simple integral multiples, the curve should stabilize into a fixed pattern. But that wasn&rsquo;t happening, and I realized that the interpolated curve
 was slightly different depending on the actual sampled points.&nbsp;</p>
<p>This problem was exacerbated on the phone, mostly due to the tiny phone processor having trouble keeping up with all the demands I was putting on it. At higher frequencies, the Lissajous curves on the phone looked smooth and curvy, but seemingly moving in
 almost random patterns!</p>
<p>Only slowly did I realize that I could interpolate based on time. Two consecutive calls to the CompositionTarget.Rendering event handler are about 17 ms apart. I could simply loop through all these intermediate millisecond values and call the GetAxisValue
 method in the two SineCurve providers to construct a smoother polyline.</p>
<p>That approach worked much better.</p>
<h2>Improving Performance</h2>
<p>One piece of essential reading for all Windows Phone 7 programmers is the documentation page &ldquo;Performance Considerations in Applications for Windows Phone&rdquo; at&nbsp;<a id="ctl00_MTContentSelector1_mainContentContainer_ctl10" href="http://bit.ly/fdvh7Z">bit.ly/fdvh7Z</a>.
 Aside from many helpful hints about improving performance in your phone applications, it will also tell you the meaning of those numbers that are displayed at the side of the screen when you run the program under Visual Studio, as shown in&nbsp;<strong>Figure
 5</strong>.</p>
<p><img title="Performance Indicators in Windows Phone 7" src="http://i.msdn.microsoft.com/gg983480.Petzold_Figure5_hires(en-us,MSDN.10).jpg" alt="image: Performance Indicators in Windows Phone 7"></p>
<p>Figure 5&nbsp;<strong>Performance Indicators in Windows Phone 7</strong></p>
<p>This row of numbers is enabled by setting the Application.Current.Host.Settings.EnableFrameRateCounter property to true, which the standard App.xaml.cs file does if the program is running under the Visual Studio debugger.</p>
<p>The first two numbers are the most significant: Sometimes, if nothing is going on, these two numbers display zero, but they&rsquo;re both intended to display frame rates&mdash;which means they display a number of frames per second. I mentioned that most
 video displays are refreshed at the rate of 60 times per second. However, an application program might attempt to perform animations where each new frame requires more than 16 or 17 ms of processing time.</p>
<p>For example, suppose a CompositionTarget.Rendering handler requires 50 ms to do whatever job it&rsquo;s doing. In that case, the program will be updating the video display at the rate of 20 times per second. That&rsquo;s the program&rsquo;s frame rate.</p>
<p>Now 20 frames per second is not a terrible frame rate. Keep in mind that movies run at 24 frames per second, and standard television has an effective frame rate (taking interlacing into account) of 30 frames per second in the United States, and 25 in Europe.
 But once the frame rate drops to 15 or 10, it&rsquo;s going to start being noticeable.</p>
<p>Silverlight for Windows Phone is able to offload some animations to the Graphics Processing Unit (GPU), so it has a secondary thread (sometimes referred to as the composition or GPU thread) that interacts with the GPU. The first number is the frame rate
 associated with that thread. The second number is the UI frame rate, which refers to the application&rsquo;s primary thread. That&rsquo;s the thread that any CompositionTarget.Rendering handlers run in.</p>
<p>Running the LissajousCurves program on my phone, I saw numbers of 22 and 11, respectively, for the GPU and UI threads, and they dropped down a bit when I increased the frequency of the sine curves. Could I do better?</p>
<p>I began to wonder how much time this crucial statement in my CompositionTarget.Rendering method required:</p>
<div class="scriptcode">
<div class="pluginEditHolder" pluginCommand="mceScriptCode">
<div class="title"><span>C#</span></div>
<div class="pluginLinkHolder"><span class="pluginEditHolderLink">Edit</span>|<span class="pluginRemoveHolderLink">Remove</span></div>
<span class="hidden">csharp</span>
<pre class="hidden">writeableBitmap.Render(polyline, null);</pre>
<div class="preview">
<pre class="js">writeableBitmap.Render(polyline,&nbsp;null);&nbsp;
&nbsp;</pre>
</div>
</div>
</div>
<div class="CodeHighlighter"></div>
<p>This statement should have been called 60 times per second with a polyline consisting of 16 or 17 lines, but it was actually being called more like 11 times per second with 90-segment polylines.</p>
<p>For my book, &ldquo;Programming Windows Phone 7&rdquo; (Microsoft Press, 2010), I wrote some line-rendering logic for XNA, and I was able to adapt that for Silverlight for this Oscilloscope class. Now I wasn&rsquo;t calling the Render method of WriteableBitmap
 at all, but instead directly altering pixels in the bitmap to draw the polylines.</p>
<p>Unfortuntely, both frame rates plunged to zero! This suggested to me that Silverlight knew how to render lines on a bitmap much faster than I did. (I should also note that my code was not optimized for polylines.)</p>
<p>At this point, I began wondering if an approach other than WriteableBitmap might be reasonable. I substituted a Canvas for the WriteableBitmap and Image element, and as each Polyline was constructed, I simply added that the Canvas.</p>
<p>Of course, you can&rsquo;t do this indefinitely. You don&rsquo;t want a Canvas with hundreds of thousands of children. And besides, these Polyline children needed to fade out. I tried two approaches: The first involved attaching a ColorAnimation to each
 Polyline to decrease the alpha channel of the color, and then removing the Polyline from the Canvas when the animation completed. The second was a more manual approach of enumerating through the Polyline children, decreasing the alpha channel of the color
 manually, and removing the child when the alpha channel got down to zero.</p>
<p>These four methods still exist in the Oscilloscope class, and they&rsquo;re enabled with four #define statements at the top of the C# file.&nbsp;<strong>Figure 6</strong>&nbsp;shows the frame rates with each approach.</p>
<p>Figure 6&nbsp;<strong>Frame Rates for the Four Oscilloscope Updating Methods</strong></p>
<table border="0" style="border-collapse:collapse; border:1px solid silver">
<tbody>
<tr style="display:table-row">
<td valign="bottom" style="border-collapse:collapse; padding:3px; border:1px solid silver">
&nbsp;</td>
<td valign="bottom" style="border-collapse:collapse; padding:3px; border:1px solid silver">
Composition Thread</td>
<td valign="bottom" style="border-collapse:collapse; padding:3px; border:1px solid silver">
UI Thread</td>
</tr>
<tr style="display:table-row">
<td valign="bottom" style="border-collapse:collapse; padding:3px; border:1px solid silver">
WriteableBitmap with Polyline render</td>
<td valign="bottom" style="border-collapse:collapse; padding:3px; border:1px solid silver">
22</td>
<td valign="bottom" style="border-collapse:collapse; padding:3px; border:1px solid silver">
11</td>
</tr>
<tr style="display:table-row">
<td valign="bottom" style="border-collapse:collapse; padding:3px; border:1px solid silver">
WriteableBitmap with manual outline fills</td>
<td valign="bottom" style="border-collapse:collapse; padding:3px; border:1px solid silver">
0</td>
<td valign="bottom" style="border-collapse:collapse; padding:3px; border:1px solid silver">
0</td>
</tr>
<tr style="display:table-row">
<td valign="bottom" style="border-collapse:collapse; padding:3px; border:1px solid silver">
Canvas with Polyline with animation fade-out</td>
<td valign="bottom" style="border-collapse:collapse; padding:3px; border:1px solid silver">
20</td>
<td valign="bottom" style="border-collapse:collapse; padding:3px; border:1px solid silver">
20</td>
</tr>
<tr style="display:table-row">
<td valign="bottom" style="border-collapse:collapse; padding:3px; border:1px solid silver">
Canvas with Polyline with manual fade-out</td>
<td valign="bottom" style="border-collapse:collapse; padding:3px; border:1px solid silver">
31</td>
<td valign="bottom" style="border-collapse:collapse; padding:3px; border:1px solid silver">
15</td>
</tr>
</tbody>
</table>
<p><strong>Figure 6</strong>&nbsp;tells me that my original instinct about WriteableBitmap was wrong. In this case, it&rsquo;s really better to put a bunch of Polyline elements in a Canvas. The two fade-out techniques are interesting: When performed by an animation,
 the fading out occurs in the composition thread at 20 frames per second. When performed manually, it&rsquo;s in the UI thread at 15 frames per second. However, adding new Polyline elements always occurs in the UI thread, and that frame rate is 20 when fading-out
 logic is off-loaded to the GPU.</p>
<p>In conclusion, the third method has the best overall performance.</p>
<p>So what have we learned today? Clearly, to eke out the best performance, it&rsquo;s necessary to experiment. Try different approaches, and never, ever trust your initial instincts.</p>
<hr>
<p><strong>Charles Petzold</strong>&nbsp;<em>is a longtime contributing editor to</em>&nbsp;MSDN Magazine<em>. His new book, &ldquo;Programming Windows Phone 7&rdquo; (Microsoft Press, 2010), is available as a free download at&nbsp;<a id="ctl00_MTContentSelector1_mainContentContainer_ctl12" href="http://bit.ly/cpebookpdf">bit.ly/cpebookpdf</a>.</em></p>
<p><em>Thanks to the following technical expert for reviewing this article:&nbsp;<strong>Jesse Liberty</strong></em></p>
<p><em><strong><br>
</strong></em></p>
<hr>
<p><a href="http://msdn.microsoft.com/en-us/magazine/gg749836.aspx" ><img src="description/gg749836.cover_lrg(en-us%2cmsdn.10)%20(1).png" alt="" width="178" height="239" style="float:left; padding-right:5px"></a></p>
<p>&nbsp;</p>
<h1>MSDN Magazine : April 2011 Issue</h1>
<h3>Windows Azure</h3>
<p>Learn about Windows Azure Caching Services and Command Query Responsibility Segregation (CQRS).</p>
<p>&nbsp;</p>
<p style="clear:both">&nbsp;</p>
<hr>
<p>&nbsp;</p>
<p style="text-align:right"><img src="description/smalllogo.png" alt="" width="197" height="84"></p>

</div>


    </div>
</body>
</html>
